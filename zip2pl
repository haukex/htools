#!/usr/bin/env perl
use warnings;
use strict;
use open qw/:std :utf8/;
use Data::Dumper;
use Archive::Zip qw/AZ_OK/;
use MIME::Base64 qw/encode_base64/;
use Encode;

# For AUTHOR, COPYRIGHT, AND LICENSE see the bottom of this file

our $VERSION = '0.01';

@ARGV==1 or die "Usage: $0 ZIPFILE";
my $zip = Archive::Zip->new();
$zip->read( $ARGV[0] ) == AZ_OK or die 'zip read error';

print <<'ENDPL';
use warnings;
use strict;
use utf8;
use Archive::Zip 'AZ_OK';
use MIME::Base64 'decode_base64';
my $zip = Archive::Zip->new();
ENDPL
print "# This code was generated by zip2pl $VERSION from ".perlstr($ARGV[0]),"\n";

for my $m ($zip->members) {
	next if $m->isDirectory;
	my $data = $m->contents;
	my $decoded;
	my $utf8ok = eval { local $SIG{__WARN__} = sub { die @_ };
		$decoded = decode('UTF-8', $data, Encode::FB_CROAK
			| Encode::LEAVE_SRC ); 1 };
	my $endtag = 'END';
	my $str;
	if ($utf8ok) {
		# if needed, generate end tags until we find one that isn't part of the text
		# not the most efficient code, but it should work for many cases
		#TODO Later: better end tag generation?
		# (note: needs to be deterministic!)
		my $tagcnt = 0;
		while ($decoded=~/^\Q$endtag\E$/m) {
			$endtag = 'END_'.encode_base64("$tagcnt",'');
			die "couldn't generate a unique end tag" if ++$tagcnt>9999999;
		}
		if ( substr($decoded,-1) eq "\n" ) {
			$str = 'do{utf8::encode(my $x=<<\''.$endtag.'\');$x}';
		}
		else {
			$decoded .= "\n";
			$str = 'do{chop(my $x=<<\''.$endtag.'\');utf8::encode($x);$x}';
		}
	}
	else {
		$decoded = encode_base64($data);
		$str = q{decode_base64(<<'END')};
	}
	print '$zip->addString(',$str,',',perlstr($m->fileName),');',"\n";
	print $decoded;
	print $endtag, "\n";
}

print <<'ENDPL';
binmode STDOUT;
$zip->writeToFileHandle(\*STDOUT,0) == AZ_OK
	or die "Failed to write ZIP";
ENDPL

sub perlstr {  ## no critic (RequireArgUnpacking)
	die "bad args to perlstr" if @_!=1 || ref($_[0]);
	return Data::Dumper->new([shift])->Terse(1)->Purity(1)->Useqq(1)
		->Indent(0)->Dump;
}

__END__

=head1 SYNOPSIS

Convert a ZIP file to a Perl script

=head1 DESCRIPTION

B<Warning:> This is a very early version; it cannot yet convert arbitrary
ZIP files! For example, empty directories are not supported, file
attributes, etc. Please test the filter first on your ZIP files to see
how accurate the reproduction is!

=head2 C<git> FILTER

If you set this script up as a C<git> filter in a repository, then what
will get checked into the repository is a Perl script, instead of the
ZIP file. This might be useful because you can do textual comparisons
between versions of the ZIP file in the repository's history.

To set this up: in F<.gitattributes>, add:

 *.zip	filter=zip2pl

And run these commands (make sure to specify the absolute path to F<zip2pl>):

 git config --local filter.zip2pl.clean '/path/to/zip2pl %f'
 git config --local filter.zip2pl.smudge perl

If you've already added F<.zip> files to the repository, you can run the
filter via C<git add --renormalize FILENAME.zip>.

=head1 AUTHOR, COPYRIGHT, AND LICENSE

Copyright (c) 2019 Hauke Daempfling (haukex@zero-g.net)
at the Leibniz Institute of Freshwater Ecology and Inland Fisheries (IGB),
Berlin, Germany, L<http://www.igb-berlin.de/>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but B<WITHOUT ANY WARRANTY>; without even the implied warranty of
B<MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE>. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see L<http://www.gnu.org/licenses/>.

=cut
