#!/usr/bin/env perl
use warnings;
use strict;
use open qw/:std :utf8/;
use Data::Dumper;
use Archive::Zip qw/AZ_OK/;
use MIME::Base64 qw/encode_base64/;
use Time::Piece;
use Getopt::Std 'getopts';
use Encode;

# For AUTHOR, COPYRIGHT, AND LICENSE see the bottom of this file

our $VERSION = '0.03';

getopts(join('',0..9),\my %opts) or die "bad options";
my @lvl = grep {/\A[0-9]\z/} keys %opts;
die "can only specify one compression level" if @lvl>1;
my $level = $lvl[0]//6;

my $zip = Archive::Zip->new();
my $filename;
if (!@ARGV || @ARGV==1 && $ARGV[0] eq '-') {
	$filename = 'STDIN';
	# readFromFileHandle requires seekable handle (don't close it!)
	my $data = do { local $/=undef; binmode STDIN; <STDIN> };
	open my $fh, '+<', \$data or die $!;  ## no critic (RequireBriefOpen)
	$zip->readFromFileHandle($fh) == AZ_OK or die 'zip read error';
}
elsif (@ARGV==1) {
	$filename = perlstr($ARGV[0]);
	$zip->read($ARGV[0]) == AZ_OK or die 'zip read error';
}
else { die "Usage: $0 [ZIPFILE]" }

print <<'ENDPL';
use warnings;
use strict;
use utf8;
use Archive::Zip 'AZ_OK';
use MIME::Base64 'decode_base64';
my $zip = Archive::Zip->new();
ENDPL
print "# This code was generated by zip2pl $VERSION from $filename\n";
print "\$zip->zipfileComment(",perlstr($zip->zipfileComment),");\n"
	if length $zip->zipfileComment;
print "\n";

for my $m ($zip->members) {
	print "{# ##### ##### ##### ",perlstr($m->fileName)," ##### ##### #####\n";
	if ($m->isDirectory) {
		print 'my $m=$zip->addDirectory(',perlstr($m->fileName),');',"\n";
	}
	else {
		my $data = $m->contents;
		my $decoded;
		my $utf8ok = eval { local $SIG{__WARN__} = sub { die @_ };
			$decoded = decode('UTF-8', $data, Encode::FB_CROAK
				| Encode::LEAVE_SRC ); 1 };
		my $endtag = 'END';
		my $str;
		if ($utf8ok) {
			# if needed, generate end tags until we find one that isn't part of the text
			# not the most efficient code, but it should work for many cases
			#TODO Later: better end tag generation?
			# (note: needs to be deterministic!)
			my $tagcnt = 0;
			while ($decoded=~/^\Q$endtag\E$/m) {
				$endtag = 'END_'.encode_base64("$tagcnt",'');
				die "couldn't generate a unique end tag" if ++$tagcnt>9999999;
			}
			if ( substr($decoded,-1) eq "\n" ) {
				$str = 'do{utf8::encode(my $x=<<\''.$endtag.'\');$x}';
			}
			else {
				$decoded .= "\n";
				$str = 'do{chop(my $x=<<\''.$endtag.'\');utf8::encode($x);$x}';
			}
		}
		else {
			$decoded = encode_base64($data);
			$str = 'decode_base64(<<\''.$endtag.'\')';
		}
		print 'my $m=$zip->addString(',$str,',',perlstr($m->fileName),",$level);\n";
		print $decoded;
		print $endtag, "\n";
	}
	print "\$m->desiredCompressionMethod(",$m->compressionMethod,");\n";
	my $fatf = $m->fileAttributeFormat;
	die "unexpected fileAttributeFormat ".perlstr($fatf) unless $fatf=~/\A\d+\z/;
	print "\$m->fileAttributeFormat($fatf);\n";
	print "\$m->fileComment(",perlstr($m->fileComment),");\n"
		if length $m->fileComment;
	print "\$m->localExtraField(",perlstr($m->localExtraField),");\n"
		if length $m->localExtraField;
	print "\$m->cdExtraField(",perlstr($m->cdExtraField),");\n"
		if length $m->cdExtraField;
	print "\$m->isTextFile(",$m->isTextFile?1:0,");\n";
	my $attr = $m->unixFileAttributes;
	die "unexpected unixFileAttributes ".perlstr($attr) unless $attr=~/\A\d+\z/;
	printf "\$m->unixFileAttributes(0%06o);\n", $attr;
	my $mtime = $m->lastModTime;
	die "unexpected lastModTime ".perlstr($mtime) unless $mtime=~/\A\d+\z/;
	print "\$m->setLastModFileDateTimeFromUnix($mtime); # ",gmtime($mtime)->datetime,"\n";
	print "}\n";
}

print <<'ENDPL';
# ##### ##### #####
binmode STDOUT;
$zip->writeToFileHandle(\*STDOUT,0) == AZ_OK
	or die "Failed to write ZIP";
ENDPL

sub perlstr {  ## no critic (RequireArgUnpacking)
	die "bad args to perlstr" if @_!=1 || ref($_[0]);
	return Data::Dumper->new([shift])->Terse(1)->Purity(1)->Useqq(1)
		->Indent(0)->Dump;
}

__END__

=head1 SYNOPSIS

Convert a ZIP file to a Perl script

=head1 DESCRIPTION

You may specify a compression level with an argument of C<-0> (no compression)
through C<-9> (maximum compression). The default is C<-6>.

=head2 CAVEATS AND LIMITATIONS

Although this script converts common ZIP file attributes, it may not reproduce
every aspect of every ZIP file with perfect accuracy. For example, the
resulting ZIP file may have a different compression level (unless you specify
it explicitly), and advanced attributes may not be supported. Please test the
filter first on your ZIP files to see how accurate the reproduction is!

=head2 C<git> FILTER

If you set this script up as a C<git> filter in a repository, then what
will get checked into the repository is a Perl script, instead of the
ZIP file. This might be useful because you can do textual comparisons
between versions of the ZIP file in the repository's history.

To set this up: in F<.gitattributes>, add:

 *.zip	filter=zip2pl

And run these commands (make sure to specify the absolute path to F<zip2pl>,
or make sure it's in your C<PATH>):

 git config --local filter.zip2pl.clean /path/to/zip2pl
 git config --local filter.zip2pl.smudge perl

If you've already added F<.zip> files to the repository, you can run the
filter via C<git add --renormalize FILENAME.zip>.

=head1 AUTHOR, COPYRIGHT, AND LICENSE

Copyright (c) 2019 Hauke Daempfling (haukex@zero-g.net)
at the Leibniz Institute of Freshwater Ecology and Inland Fisheries (IGB),
Berlin, Germany, L<http://www.igb-berlin.de/>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but B<WITHOUT ANY WARRANTY>; without even the implied warranty of
B<MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE>. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see L<http://www.gnu.org/licenses/>.

=cut
